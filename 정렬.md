## 선택 정렬(Selection Sort)

- 선택 정렬은 **매 단계**에서 가장 작은 원소를 선택해서 앞으로 보내는 정렬 방법이다.
- 앞으로 보내진 원소는 더 이상 위치가 변경되지 않는다.
- 시간 복잡도 O(N^2)로 <U>비효율적인 정렬 알고리즘 중 하나</U>다.

### 선택 정렬의 동작 방식

1. 각 단계에서 가장 <U>가장 작은 원소</U>를 선택한다.
2. 현재까지 처리되지 않은 원소들 중 \*\*가장 앞의 원소와 위치를 교쳬한다.

```
// 선택 정렬 함수
function selectionSort(arr) {
  for (let i=0; i<arr.length; i++) {
    let minIndex = i; //가장 작은 원소의 인덱스
    if (arr[minIndex] > arr[j]) {
      minIndex = j;
    }
  }
  // 스와프(swap)
  let temp = arr[i];
  arr[i] = arr[minIndex];
  arr[minIndex] = temp;
}

```

### 선택 정렬의 시간복잡도

- 선택 정렬이란 <u>가장 작은 것을 선택해서 앞으로 보내는 정렬 기법</u>이다.
- 매 단계에서 가장 작은 것을 선택하는 데에 약 N번의 연산이 필요하다.(선형 탐색)
- 결과적으로 약 N개의 단계를 거친다는 점에서 최악의 경우 O(N^2)의 시간복잡도를 가진다.

## 버블 정렬(Bubble Sort)

- 단순히 인접한 두 원소를 확인하여, 정렬이 안되어 있다면 위치를 서로 변경한다.
- 서로 인접한 두 원소를 비교하는 형태가 **거품**과 같다고 하여 붙여진 이름이다.
- 시간 복잡도 O(N^2)로 <u>비효율적인 정렬 알고리즘 중 하나</u>이다.

### 버블 정렬의 동작 방식

- 각 단계에서의 **인접한 두개의 원소를 비교**하여, <u>필요 시 위치를 변경</u>한다.
- 첫째와 둘째를 비교, 둘째와 셋째를 비교, 셋째와 넷째를 비교하는 방식이다.

```
function bubbleSort(arr) {
  for (let i=arr.length-1; i>0; i--) {
    for (let j=0; j<i; j++) {
      if (arr[j] < arr[j+1]) {
        let temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
      }
    }
  }
}
```

### 버블 정렬의 시간복잡도

- 최악의 경우 시간 복잡도 O(N^2)를 보장한다.
- 이미 정렬된 배열에 대해서 모든 비교가 필요하므로, 굉장히 비효율적인 정렬 알고리즘 중 하나에 속한다.

## 삽입 정렬(Insertion Sort)

- 삽입 정렬이란 각 숫자를 적절한 위치에 삽입하는 정렬 기법이다.

### 삽입 정렬의 동작 방식

1. 각 단계에서 현재 원소가 삽입될 위치를 찾는다.
2. 적절한 위치에 도달할 때까지 반복적으로 <u>왼쪽으로 이동</u>한다.

```
function insertionSort(arr) {
  for (let i=1; i< arr.length; i++) {
    for (let j=i; j>0; j--) {
      // 인덱스 j부터 1까지 1씩 감소하며 반복
      if (arr[j] < arr[j-1]) {
        // 한 칸씩 왼쪽으로 이동
        // 스와프(swap)
        let temp = arr[j];
        arr[j] = arr[j-1];
        arr[j-1] = temp;
      } else {
        // 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
        break;
      }
    }
  }
}
```

### 삽입 정렬의 시간 복잡도

- 삽입 정렬이란 각 원소를 적절한 위치에 **삽입**하는 정렬 기법이다.
- 매 단계에서 현재 처리 중인 원소가 삽입될 위치를 찾기 위해 약 N번의 연산이 필요하다.
- 결과적으로 약 N개의 단계를 거친다는 점에서 최악의 경우 O(N^2)의 시간 복잡도를 가진다.

## 병합 정렬(Merge Sort)

- 이번 시간에는 병합 정렬에 대하여 알아볼 것이다.
- 병합 정렬은 <u>전형적인</u> \*\*분학 정복(divide and conquer) 알고리즘이다.

### 분학 정복(divide and conquer)

1. **분할(divide):** 큰 문제를 작은 부분 문제(쉬운 문제)로 분할한다.
2. **정복(conquer):** 작은 부분 문제를 각각 해결한다.
3. **조합(combine):** 해결한 부분 문제의 답을 이용하여 다시 큰 문제를 해결한다.

- 분할 정복은 일반적으로 재귀 함수를 이용하여 구현한다.
- 그 이유는? 큰 문제를 작은 문제로 "<u>분할하는 방식이 동일한</u>" 경우가 많기 때문이다.
- 더 이상 쪼갤 수 없는 크기가 될 때까지 계속하여 분할한다.

- 분할정복의 단점

  - **일반적으로 재귀 함수를 사용**한다는 점에서 함수 호출 횟수가 많이 발생한다.
  - 이는 `오버헤드(overhead)`로 이어진다.

- 시간 복잡도 O(NlogN)을 보장하는 빠른 정렬 알고리즘 중 하나이다.

### 병합 정렬의 동작 방식

- 병합 정렬은 분할 정복을 이용하는 가장 기본적인 정렬 알고리즘이다.

1. **분할(divide):** 정렬할 배열(큰 문제)을 같은 크기의 부분 배열(작은 문제) 2개로 분할한다.
2. **정복(conquer):** 부분 배열을 정렬한다. (작은 문제를 해결한다.)
3. **조합(combine):** 정렬된 부분 배열을 하나의 배열로 다시 병합한다.

#### 정복

- 각 부분 배열은 이미 정렬된 상태로 본다.
- 각 부분 배열에 대하여 **첫째 원소부터 시작하여 하나씩 확인**한다.
- 총 원소의 개수가 N개일 때, O(N)의 시간 복잡도가 요구된다.

### 병랍 정렬의 시간 복잡도

- 직관적으로 생각했을 때, **높이**가 O(logN)이고, **너비**가 O(N)인 정사각형과 유사하다.
- 따라서 최악의 경우 <u>시간 복잡도</u>는 O(NlogN)이다.
- **장점**: 최악의 경우에도 O(NlogN)을 보장할 수 있다는 점에서 효율적이다.
- **단점**: 일반적인 경우, 정복(conquer)과정에서 **임시 배열이 필요**하다.

```
function merge(arr, left, mid, right) {
  let i = left;
  let j = mid + 1;
  let k = left; // 결과 배열의 인덱스
  while (i <=mid && j<= right) {
    if (arr[i] <= arr[j]) sorted[k++] = arr[i++];
    else sorted[k++] = arr[j++];
  }
  // 왼쪽 배열에 대한 처리가 다 끝난 경우
  if (i > mid) {
    for (; j<= right; j++) sorted[k++] = arr[j];
  }
  // 오른쪽 배열에 대한 처리가 다 끝난 경우
  else {
    for (; i<= mid; i++) sorted[k++] = arr[i];
  }
  // 정렬된 배열 결과를 원본 배열에 반영하기
  for (let x = left; x<= right; x++) {
    arr[x] = sorted[x];
  }
}

function mergeSort(arr, left, right) {
  // 원소가 1개인 경우, 해당 배열은 정렬이 된 상태로 이해 가능
  if (left < right) {
    // 원소가 2개 이상이라면
    let mid = parseInt((left + right) / 2); // 2개의 부분 배열로 분할(divide)
    mergeSort(arr, left, mid); // 왼쪽 부분 배열 정렬 수행(conquer)
    mergeSort(arr, mid + 1, right); // 오른쪽 부분 배열 정렬 수행(conquer)
    merge(arr, left, mid, right); // 정렬된 2개의 배열을 하나로 병합(combine)
  }
}
```

### javascript 정렬 라이브러리

- js에서는 배열에 포함된 데이터를 정렬하는 sort() 함수를 제공한다.
- 최악의 경우 시간 복잡도 O(NlogN)을 보장한다.
- **알고리즘 및 코딩 테스트 문제**를 해결할 때 정렬 기능이 필요하다면 단순히 sort()함수를 사용하는 것이 권장된다.
- 만약, sort() 함수의 사용이 제한된다면, 병합 정렬과 같은 알고리즘일 직접 구현하여 사용하자.

#### 정렬 기준 함수(compareFunction)

- js 배열의 sort 메소드에서 인자로 받는 콜백함수
- 정렬 기준을 정해주는 함수이다.
- 내림차순, 오름차순 등 구체적인 정렬 기준을 설정할 수 있다.

```
arr.sort(compareFunction)
```

- 두개의 원소 a,b를 입력으로 받는다.

  1. 반환 값이 0보다 작은 경우 -> a가 우선순위가 높아, 앞에 위치한다.
  2. 반환 값이 0보다 큰 경우 -> b가 우선순위가 높아, 앞에 위치한다.
  3. 반환 값이 0인 경우 -> a와 b의 순서를 변경하지 않는다.

- 참고사항
  - 정렬 기준 함수를 사용하지 않으면 <u>각 원소는 문자열로 취급한다.</u>
  - **유니코드 값 순서대로 정렬**된다.
  - 따라서, 항상 <u>정렬 기준 함수를 명시</u>하는 습관을 들일 필요가 있다.
